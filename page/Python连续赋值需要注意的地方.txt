在python中是可以使用连续赋值的方式来一次为多个变量进行赋值的，比如：

a = b = c = 1
a, b, c = 1, 1, 1

这些都可以完成变量的赋值，但是就有一个问题了，比如：

a = 3
a, b = 1, a

如果按照正常的思维逻辑，先进行a = 1，在进行b = a，最后b应该等于1，但是这里b应该等于3，因为在连续赋值语句中等式右边其实都是局部变量，而不是真正的变量值本身，比如，上面例子中右边的a，在python解析的时候，只是把变量a的指向的变量3赋给b，而不是a=1之后a的结果，这一点刚开始学python的人可能容易误解，再举一个Leetcode里链表的例子理解就更深了。

假如要对一个链表进行翻转，就比如把1—>2->3->4转化为4->3->2->1

对于这个问题很简单，只要反转指针就可以了，假如链表结构为：

class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None

我们可以用很简单的三行代码完成这个过程：

def reverseList(self, head):
        L = ListNode(float("-inf"))
        while head:
            L.next, head.next, head = head, L.next, head.next
        return L.next

这里的L是指向一个新建的结点，因为python没有指针的概念，所以用一个额外的结点来代替头指针，这里的核心代码就是中间那一行三个变量的连续赋值，如果单独一句句来理解的话，最后肯定是想不通的，在这里，假设head结点是链表串’1->2->3->4’的头结点，先用新的L结点的next指针指向head的第一个结点‘1’，之后将L.next(第一次也就是空)赋给了head的next指针，之后再把head的next指针（注意，这里的next指针还是指向‘2’的，而不是空）赋给head，相当于next向前移一位，这一步相当于一个串变成了两个：

L：‘-inf’->‘1’
head：‘2’->‘3’->‘4’->‘5’

